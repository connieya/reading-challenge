# 3일차 p.103 ~ 127

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

> **오브젝트의 동일성 과 동등성** <br/>
> 
> 자바에서 두 개의 오브젝트가 같은가라는 말은 주의해서 써야 한다 자바에서는 두 개의 오브젝트가 완전히 같은
> 동일한(identical) 오브젝트라고 말하는 것과, 동일한 정보를 담고 있는 (equivalent) 오브젝트라고 말하는 것은
> 분명히 차이가 있다. 전자는 동일성(identity) 비교라고 하고,
> 후자를 동등성(equality) 비교라고 한다. 동일성은 == 연산자로, 동등성은 equals() 메소드를 이용해 비교한다.
> <br/>
> 
> 두 개의 오브젝트가 동일하다면 사실은 하나의 오브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐이다.
> 두 개의 오브젝트가 동일하지는 않지만 동등한 경우엔느 두 개의 각기 다른 오브젝트가 메모리상에 존재하는 것인데,
> 오브젝트의 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단하는 것일 뿐이다. 물론 
> 동일한 오브젝트는 동등하기도 할 것이다. 하지만 그 반대는 항상 참이 아니다.
> <br/>
> 
> 자바 클래스를 만들 때 equals() 메소드를 따로 구현하지 않았다면, 최상위 클래스인 Object 클래스에
> 구현되어 있는 equals() 메소드가 사용된다. Object 의 equals() 메소드는 두 오브젝트의 동일성을 비교해서
> 그 결과를 돌려준다. 따라서 이때는 동일한 오브젝트여야지만 동등한 오브젝트라고 여겨질 것이다.

알아보고 싶은 것은 
DaoFactory 의 userDao() 를 여러 번 호출했을 때 동일한 오브젝트가 돌아오는가 아닌가이다.


`리스트 1-20 직접 생성한 DaoFactory 오브젝트 출력 코드`

```java
DaoFactory factory = new DaoFactory();
UserDao dao1 = factory.userDao();
UserDao dao2 = factory.userDao();

System.out.println(dao1);
System.out.println(dao2);
```

리스트 1-20 의 코드를 실행하면 다음과 같은 결과가 나온다. 
출력되는 값은 매번 달라질 수 있다.

출력 결과에서 알 수 있듯이, 두 개는 각기 다른 값을 가진 동일하지 않은 오브젝트다.
즉 오브젝트가 두 개가 생겼다는 사실을 알 수 있다.

스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다는 것이다.
단순하게 getBean() 을 실행할 때마다 userDao() 메소드를 호출하고, 매번 new 에 의해 새로운 UserDao가 만들어지지 않는다는 뜻이다.

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 콘텍스트

애플리케이션 콘텍스트는 우리가 만들었던 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너다.
그러면서 동시에 이 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리 이기도 하다.

스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.


#### 서버 애플리케이션과 싱글톤

태생적으로 스프링은 엔터프라이즈 시스템을 위해 고안된 기술이기 때문에 서버 환경에서 사용될 때 그 가치가 있다.
실제로 스프링은 대부분 서버환경에서 사용된다.


엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다.
서블릿은 자바 엔터프리자이 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 있다.

서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에  사용한다.


> **싱글톤 패턴(Singleton Pattern)**
> <br/>
> 디자인 패턴 중에서 가장 자주 활용되는 패턴이기도 하지만 가장 많은 비판을 받는 패턴이기도 하다. 
> <br/>
> 싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다.


#### 싱긑톤 패턴의 한계

`리스트 1-22 싱글톤 패턴을 적용한 UserDao`

일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.

- private 생성자를 갖고 잇기 때문에 상속할 수 없다.

애플리케이션의 로직을 담고 있는 일반 오브젝트의 경우 싱글톤으로 만들었을 때 객체지향적인 설계의 장점을 적용하기가 어렵다는 점은 
심각한 문제다.

- 싱글톤은 테스트하기가 힘들다.

싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다.

- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.

- 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.


#### 싱글톤 레지스트리

자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을
제공한다. 그것이 바로 싱글톤 레지스트리다. 


평범한 자바 클래스라도 IoC 방식의 컨테이너를 사용해서 생성과 관계 설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면
손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.

스프링은 IoC 컨테이너일 뿐만 아니라, 고전적인 싱글톤 패턴을 대신해서 싱글톤을 만들고 관리해주는 싱글톤 레지스트리라는 점을 기억해두자.


싱글톤으로 만들어지기 때문에 주의해야 할 점


### 1.6.2 싱글톤과 오브젝트의 상태

싱글톤은 멀티 스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리에 주의를 기울여야 한다.

다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험하다.

따라서 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지(stateful) 방식으로 만들지 않는다.

메소드 파라미터나 , 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에
싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다.


### 1.6.3 스프링 빈의 스코프

스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 
스프링 컨테이너가 존재하는 동안 계속 유지된다.


## 1.7 의존관계 주입 (DI)

### 1.7.1 제어의 역전(IoC) 과 의존관계 주입

DaoFactory 처럼 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 스프링의 IoC 컨테이너다.

한 가지 짚고 넘어갈 것은 여기서 사용하는 IoC 라는 용어인데, IoC 가 매우 느슨하게 정의 돼서 
폭넓게 사용되는 용어라는 점이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다.

스프링이 제공하는 IoC 방식을 핵심을 짚어주는 의존 관계 주입 이라는, 좀 더 의도가 명확히 드러나는 이름을 사용하기 시작했다.

> **의존관계 주입, 의존성 주입,  의존 오브젝트 주입?**
> <br/>


### 1.7.2 런타임 의존관계 설정

#### 의존괸계

의존한다는 건 의존 대상, 여기서는 B가 변하면 그것이 A에 영향을 미친다는 뜻이다.

의존하지 않는다는 말은 B는 A의 변화에 영향을 받지 않는다는 뜻이다.

#### UserDao 의 의존관계

ConnectionMaker 인터페이스가 변한다면, 그 영향을 UserDao 가 직접적으로 받게 된다.
하지만 ConnectionMaker 인터페이스를 구현한 클래스, 즉 DConnectionMaker 등이 다른 것으로 바뀌거나 그 내 부에서 사용하는 메서드에
변화가 생겨도 UserDao 에 영향을 주지 않는다.

이렇게 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다.

모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존 관계 말고, 런타임 시에 오브젝트 사이에서 만들어지는
의존관계도 있다.

프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인
오브젝트를 **의존 오브젝트**라고 말한다.

의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업을 말한다.

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.

의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것이다.

#### UserDao 의 의존관계 주입


런타임 시점의 의존관계를 결정하고 만들려면 제 3의 존재가 필요하다고 했다.

보통 DI는 그 근간이 되는 개념인 IoC 와 함께 사용해서 IoC/DI 컨테이너라는 식으로 함께 사용하기도 한다.

자바에서 오브젝트에 무엇인가를 넣어준다는 개념은 메소드를 실행하면서 파라미터로 오브젝트의 레퍼런스를 전달해주는 방법 뿐이다.

`리스트 1-25 의존관계 주입을 위한 코드`


DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서
IoC의 개념에 잘 들어맞는다.

### 1.7.3 의존관계 검색과 주입

스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다.

의존 관계 검색은 자신이 필요로 하는 오브젝트를 능동적으로 찾는다. 물론 자신이 어떤 클래스의 오브젝트를 이용할지 결정하지는 않는다.


`리스트 1-26 DaoFactory 를 이용하는 생성자`

```java
public UserDao() {
    DaoFactory daoFactory = new DaoFactory();
    this.connectionMaker = daoFactory.connectionMaker();
}
```

런타임 시에 DaoFactory 가 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계를 맺는다.

애플리케이션 컴포넌트가 컨테이너와 같이 성격이 다른 오브젝트에 의존하게 된느 것이므로 바람직하지 않다.
사용자에 대한 DB 정보를 어떻게 가져올 것인가에 집중해야 하는 UserDao 에서 스프링이나 오브젝트 팩토리를 만들고 API를 
이용하는 코드가 섞여 있는 것은 어색하다.

UserDao 에 스프링의 getBean() 을 사용한 의존관계 검색 방법을 적용했다고 해보자. 이 경우 UserDao는 굳이  스프링이 만들고
관리하는 빈일 필요가 없다. 그냥 어딘가에서 직접 new UserDao() 해서 만들어서 사용해도 된다. 
이때는 ConnectionMaker 만 스프링의 빈이기만 하면 된다.

반면에 의존관계 주입에서는 UserDao 와 ConnecionMaker 사이에 DI가 적용되려면 UserDao도 반드시 컨테이너가 만드는 
빈 오브젝트여야 한다.


> **DI 받는다**
> <br/>


### 1.7.4 의존관계 주입의 응용

코드에는 런타임 클래스에 대한 의존관계가 나타나지 않고, 인터페이스를 통해 결합도가 낮은 코드를 만들므로,
다른 책임을 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장 방법에는 자유롭다

#### 기능 구현의 교환


#### 부가기능 추가

DI 컨테이너에서라면 아주 간단한 방법으로 가능하다.

```java
public class CountingConnectionMaker implements ConnectionMaker {
    int counter = 0;
    private ConnectionMaker realConnectionMaker;


    public CountingConnectionMaker(ConnectionMaker realConnectionMaker) {
        this.realConnectionMaker = realConnectionMaker;
    }

    @Override
    public Connection makeConnection() {
        this.counter++;
        return realConnectionMaker.makeConnection();
    }

    public int getCounter() {
        return counter;
    }
}

```

UserDao 는 ConnectionMaker 의 인터페이스에만 의존하고 있기 때문에,
ConnectionMaker 인터페이스를 구현하고 있다면 어떤 것이든 DI가 가능하다.


새로운 의존관계를 컨테이너가 사용할 설정정보를 이용해 만들어보자.
CountingDaoFactory 라는 이름의 설정용 클래스를 만든다.

기존 DaoFactory와 달리, connectionMaker()  메소드에서 CountingConnectionMaker 타입 오브젝트를 생성ㅎ라도록 만든다.

```java
@Configuration
public class CountingDaoFactory {

    @Bean
    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }
    @Bean
    public ConnectionMaker connectionMaker() {
        return new CountingConnectionMaker(realConnectionMaker());
    }
    
    @Bean
    public ConnectionMaker realConnectionMaker() {
        return new DConnectionMaker();
    }
}

```

지금은 DAO 가 하나뿐이지만 DAO 가 수십, 수백 개여도 상관없다. DI 의 장점은 관심사의 분리를 통해 얻어지는 높은 응집도에서 나온다.

### 1.7..5 메소드를 이용한 의존관계 주입

#### 수정자 메소드를 이용한 주입

#### 일반 메소드를 이용한 주입

