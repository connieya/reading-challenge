# 14일차 p.297 ~

## 4.2 예외 전환

예외를 다른 것으로 바꿔서 던지는 예외 전환의 목적은 두 가지라고 설명했다.

하나는 앞에서 적용해본 것처럼 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws 를 줄여주는 것이고,
다른 하나는 로우레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바꿔서 던져주는 것이다.

스프링의 JdbcTemplate 이 던지는 DataAccessException 은 일단 런타임 예외로 SQLException 을 포장해주는 역할을 한다.
그래서 대부분 복구가 불가능한 예외인 SQLException에 대해 애플리케이션 레벨에서 신경 쓰지 않도록 해주는 것이다. 

또한 DataAccessException은 SQLException 에 담긴 다루기 힘든 상세한 예외정보를 의미 있고 일관성 있는 예외로
전환해서 추상화해주려는 용도로 쓰이기도 한다. 

### 4.2.1 JDBC 의 한계

만약 DB 별로 다른 API를 제공하고 이를 사용해야 한다고 상상해보자.  DB가 바뀔 때마다 DAO 코드도 모두 
바뀔 것이고, 제각각 다른 API 사용법을 익혀야 할 테니 상상만 해도 끔찍하다. 

JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고, 각 DB 업체가 JDBC 표준을 따라 만들어진
드라이버를 제공하게 해준다. 내부 구현은 DB마다 다르겠지만 JDBC의 Connection , Statement, ResultSet 등의 표준 인터페이스를
통해 그 기능을 제공해주기 때문에 자바 개발자들은 표준화된 JDBC 의 API에만 익숙해지면 
DB의 종류에 상관없이 일관된 방법으로 프로그램을 개발할 수 있다.

#### 비표준 SQL
첫째 문제는 JDBC 코드에서 사용하는 SQL이다.

대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능도 제공한다.


#### 호환성 없는 SQLException 의 DB 에러 정보

두 번째 문제는 바로 SQLException 이다. DB를 사용하다가 발생할 수 있는 예외의 원인은 다양하다.

문제는 DB마다 SQL 만 다른 것이 아니라 에러의 종류와 원인도 제각각이라는 점이다. 그래서 JDBC는 데이터 처리 중에
발생하는 다양한 예외를 그냥 SQLException 하나에 모두 담아버린다. JDBC API는 이 SQLException 한 가지만 던지도록 설계되어 있다.


```java
if(e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) { ...}
```

SQLException의 에러 코드를 이용해 중복된 값의 등록이 원인인지 확인하는 것이다.
그런데 여기서 사용한 에러 코드는 MySQL 전용 코드일 뿐이다. DB가 MySQL에서 오라클이나 SQLServer 로 바뀐다면
에러 코드도 달라지므로 이 코드는 기대한 대로 동작하지 못할 것이다.


### 4.2.2 DB 에러 코드 매핑을 통한 전환

스프링은 DataAccessException 이라는 SQLException 을 대체할 수 있는 런타임 예외를 정의하고 있을 뿐 아니라
DataAccessException 의 서브클래스로 세분호된 예외 클래스들을 정의하고 있다.

JdbcTemplate 은 체크 예외인 SQLException 을 런타임 예외인 DataAccessException 계층구조의 예외로 포장해주기 대문에
add() 메소드에는 예외 포장을 위한 코드가 따로 필요 없다.

`리스트 4-17 JdbcTemplate이 제공하는 예외 전환 기능을 이용하는 add() 메소드`


JdbcTemplate 을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 거의 신경 쓰지 않아도 된다.


### 4.2.3 DAO 인터페이스와 DataAccessException 계층구조