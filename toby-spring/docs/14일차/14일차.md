# 14일차 p.297 ~ 315

## 4.2 예외 전환

예외를 다른 것으로 바꿔서 던지는 예외 전환의 목적은 두 가지라고 설명했다.

하나는 앞에서 적용해본 것처럼 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws 를 줄여주는 것이고,
다른 하나는 로우레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바꿔서 던져주는 것이다.

스프링의 JdbcTemplate 이 던지는 DataAccessException 은 일단 런타임 예외로 SQLException 을 포장해주는 역할을 한다.
그래서 대부분 복구가 불가능한 예외인 SQLException에 대해 애플리케이션 레벨에서 신경 쓰지 않도록 해주는 것이다. 

또한 DataAccessException은 SQLException 에 담긴 다루기 힘든 상세한 예외정보를 의미 있고 일관성 있는 예외로
전환해서 추상화해주려는 용도로 쓰이기도 한다. 

### 4.2.1 JDBC 의 한계

만약 DB 별로 다른 API를 제공하고 이를 사용해야 한다고 상상해보자.  DB가 바뀔 때마다 DAO 코드도 모두 
바뀔 것이고, 제각각 다른 API 사용법을 익혀야 할 테니 상상만 해도 끔찍하다. 

JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고, 각 DB 업체가 JDBC 표준을 따라 만들어진
드라이버를 제공하게 해준다. 내부 구현은 DB마다 다르겠지만 JDBC의 Connection , Statement, ResultSet 등의 표준 인터페이스를
통해 그 기능을 제공해주기 때문에 자바 개발자들은 표준화된 JDBC 의 API에만 익숙해지면 
DB의 종류에 상관없이 일관된 방법으로 프로그램을 개발할 수 있다.

#### 비표준 SQL
첫째 문제는 JDBC 코드에서 사용하는 SQL이다.

대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능도 제공한다.


#### 호환성 없는 SQLException 의 DB 에러 정보

두 번째 문제는 바로 SQLException 이다. DB를 사용하다가 발생할 수 있는 예외의 원인은 다양하다.

문제는 DB마다 SQL 만 다른 것이 아니라 에러의 종류와 원인도 제각각이라는 점이다. 그래서 JDBC는 데이터 처리 중에
발생하는 다양한 예외를 그냥 SQLException 하나에 모두 담아버린다. JDBC API는 이 SQLException 한 가지만 던지도록 설계되어 있다.


```java
if(e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) { ...}
```

SQLException의 에러 코드를 이용해 중복된 값의 등록이 원인인지 확인하는 것이다.
그런데 여기서 사용한 에러 코드는 MySQL 전용 코드일 뿐이다. DB가 MySQL에서 오라클이나 SQLServer 로 바뀐다면
에러 코드도 달라지므로 이 코드는 기대한 대로 동작하지 못할 것이다.


### 4.2.2 DB 에러 코드 매핑을 통한 전환

스프링은 DataAccessException 이라는 SQLException 을 대체할 수 있는 런타임 예외를 정의하고 있을 뿐 아니라
DataAccessException 의 서브클래스로 세분호된 예외 클래스들을 정의하고 있다.

JdbcTemplate 은 체크 예외인 SQLException 을 런타임 예외인 DataAccessException 계층구조의 예외로 포장해주기 대문에
add() 메소드에는 예외 포장을 위한 코드가 따로 필요 없다.

`리스트 4-17 JdbcTemplate이 제공하는 예외 전환 기능을 이용하는 add() 메소드`


JdbcTemplate 을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 거의 신경 쓰지 않아도 된다.


### 4.2.3 DAO 인터페이스와 DataAccessException 계층구조

DataAccessException 은 JDBC의 SQLException 을 전환하는 용도로만 만들어진 건 아니다.
JDBC 외의 자바 데이터 액세스 기술에서 발생하는 예외에도 적용된다.
자바에는 JDBC 외에도 데이터 엑세스를 위한 표준 기술이 존재한다.

DataAccessException 은 의미가 같은 예외라면 데이터 엑세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어준다.
데이터 엑세스 기술에 독립적인 추상화된 예외를 제공하는 것이다.

#### DAO 인터페이스와 구현의 분리

DAO 를 굳이 따로 만들어서 사용하는 이유는 무엇일까? 가장 중요한 이유는 데이터 엑세스 로직을 담은 코드를 
성격이 다른 코드에서 분리해놓기 위해서다. 또한 분리된 DAO는 전략 패턴을 적용해 구현 방법을 변경해서 사용할 수 있게 
만드릭 위해서이기도 하다. DAO 를 사용하는 쪽에서는 DAO 가 내부에서 어떤 데이터 엑세스 기술을 사용하는지 신경 쓰지 않아도 된다.
User 와 같은 자바빈으로 만들어진, 특정 기술에 독립적인 단순한 오브젝트를 주고받으면서 데이터 액세스 기능을 사용하기만 하면 된다. 
그런 면에서 DAO는 인터페이스를 사용해 구체적인 클래스 정보와 구현 방법을 감추고, DI를 통해 제공되도록 만드는 것이 바람직 하다.

그런데 DAO의 사용 기술과 구현 코드는 전략 패턴과 DI를 통해서 DAO를 사용하는 클라이언트에게 감출 수 있지만, 메소드 선언에 나타나는
예외정보가 문제가 될 수 있다.

`리스트 4-19 기술에 독립적인 이상적인 DAO 인터페이스`


이렇게 정의한 인터페이스는 JDBC 가 아닌 데이터 엑세스 기술로 DAO 구현을 전환하면  사용할 수 없다.
데이터 엑세스 기술의 API는 자신만의 독자적인 예외를 던지기 때문에 다음과 같이 인터페이스 메소드를 바꿔주면 모르겠지만,
SQLException 을 던지도록 선언한 인터페이스 메소드는 사용할 수 업 ㅅ다.


다행히도 JDBC 보다는 늦게 등장한 JDO , Hibernate , JPA 등의 기술은 SQLException 같은 체크 예외 대신 런타임 예외를 사용한다.
따라서 throws 에 선언을 해주지 않아도 된다.


대부분의 데이터 액세스 예외는 애플리케이션에서는 복구 불가능하거나 할 필요가 없는 것이다.
그렇다고 모든 예외를 다 무시해야 하는 건 아니다. 중복 키 에러처럼 비즈니스 로직에서 의미 있게 처리할 수 있는 예외도 있다.

문제는 데이터 액세스 기술이 달라지면 같은 상황에서도 다른 종류의 예외가 던져진다는 점이다.
중복 키 에러가 발생했을 때 JDBC로 만든 DAO에서는 SQLException 이 , JPA에서는 PersistenceException 이 ,
하이버네이트에서는 HibernateException 이 던져진다.

따라서 DAO를 사용하는 클라이언트 입장에서는 DAO 의 사용 기술에 따라서 예외 처리 방법이 달라져야 한다. 
결국 클라이언트가 DAO의 기술에 의존적이 될 수 밖에 없다.
단지 인터페이스로 추상화하고, 일부 기술에서 발생하는 체크 예외를 런타임 예외로 전환하는 것만으론 불충분하다

#### 데이터 액세스 예외 추상화와 DataAccessException 계층 구조

DataAccessException 은 자바의 주요 데이터 액세스 기술에서 발생할 수 있는 대부분의 예외를 추상화하고 있다.
데이터 액세스 기술에 상관없이 공통적인 예외도 있지만 일부 기술에서만 발생하는 예외도 있다.
JPA , 하이버네이트처럼 ORM 에서는 방생하지만 JDBC 에는 없는 예외도 있다.

예를 들어 JDBC , JDO ,JPA , 하이버네이트에 상관없이 데이터 액세스 기술을 부정확하게 사용했을 때는 
InvalidDataAccessResourceUsageException 예외가 던져진다.

또는 JDO , JPA , 하이버네이트처럼 오브젝트/엔티티 단위로 정보를 업데이트하는 경우에는 낙관적인 락킹이 발생할 수 있다.

이런 예외들은 사용자에게 적절한 안내 메시지를 보여주고, 다시 시도할 수 있도록 해줘야 한다.
하지면 역시 JDO , JPA , 하이버네이트마다 다른 종류의 낙관적인 락킹 예외를 발생시킨다.
그런데 스프링의 예외 전환 방법을 적용하면 기술에 상관없이 DataAccessException 의 서브클래스인 ObjectOptimisticLockingFailureException
으로 통일시킬 수 있다.

### 4.2.4 기술에 독립적인 UserDao 만들기

#### 인터페이스 적용

지금까지 만들어서 써왔던 UserDao 클래스를 이제 인터페이스오 구현으로 분리해보자.

UserDao 인터페이스에는 기존 UserDao 클래스에서 DAO의 기능을 사용하려는 클라이언트들이 필요한 것만 추출해내면 된다.


`리스트 4-20 UserDao 인터페이스`


`리스트 4-21 빈 클래스 변경`

클래스 이름 외에는 변경할 게 없다. 보통 빈의 이름은 클래스 이름이 아니라, dataSource 빈이 그랬던 것처럼
클래스의 구현 인터페이스 이름을 따르는 경우가 일반적이다. 그래야 나중에 구현 클래스를 바꿔도 혼란이 없기 때문이다.


#### 테스트 보완

@Autowired 는 스프링 컨텍스트 내에서 정의된 빈 중에서 인스턴스 변수에 주입 가능한 타입의 빈을 찾아준다.
UserDao는 UserDaoJdbc 가 구현한 인터페이스이므로 UserDaoTest 의 dao 변수에 UserDaoJdbc 클래스로 정의된 빈을 넣는 데  아무런 문제가 없다.


그 구현 기술에 상관없이 DAO의 기능이 동작하는 데만 관심이 있다면, UserDao 인터페이스로 받아서 테스트 하는 편이 낫다.

#### DataAccessException 활용 시 주의사항

이렇게 스프링을 활용하면 DB 종류나 데이터 액세스 기술에 상관없이 키 값이 중복이 되는 상황에서는 동일한 예외가 발생하리라고 기대할 것이다.
하지만 안타깝게도 DuplicateKeyException 은 아직까지는 JDBC를 이용하는 경우에만 발생한다.


## 4.3 정리

- 예외를 잡아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발하는 것은 위험하다.
- 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 한다.
- 좀 더 의미 있는 예외로 변경하거나, 불필요한 catch/throws 를 피하기 위해 런타임 예외로 포장하는 두 가지 방법의 예외 전환이 있다.
- 복구할 수 없는 예외는 가능한 한 빨리 런타임 예외로 전환하는 것이 바람직하다.
- 애플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다.
- JDBC 의 SQLException 은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야 한다.
- SQLException 의 에러 코드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환될 필요가 있다.
- 스프링은 DataAccessException 을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다.
- DAO를 데이터 엑세스 기술에서 독립시키려면 인터페이스 도입과 런타임 예외 전환 ,  기술에 독립적인 추상화된 예외로 전환이 필요하다.