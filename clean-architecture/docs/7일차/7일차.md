# 7일차 2024-06-27 p.80 ~ 

##  07. 아키텍처 요소 테스트 하기

### 테스트 피라미드

그림 7.1 은 몇 개의 테스트와 어떤 종류의 테스트를 
목표로 해야 하는지 결정하는 데 도움을 준다.

![img.png](img.png)

`그림 7.1 테스트 피라미드에 따르면 비용이 많이 드는 테스트는 지양하고 비용이 적게 드는 테스트를 많이 만들어야 한다.`

기본 전제는 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고, 안정적인 작은 크기의 테스트들에 대해 높은 커버리지를 유지해야 한다는 것이다.
이 테스트는 하나의 '단위 (일반적으로 하나의 클래스)' 가 제대로 동작하는지 확인할 수 있는 단위 테스트들이다.

여러 개의 단위와 단위를 넘는 경계, 아키텍처 경계 , 시스템 경계를 결합하는 테스트는 만드는 비용이 더 비싸지고,
실행이 더 느려지며 (기능 에러가 아닌 설정 에러로 인해 ) 깨지기 더 쉬워진다. 
테스트 피라미드는 테스트가 비싸질수록 테스트의 커버리지 목표는 낮게 잡아야 한다는 것을 보여준다. 
그렇지 않으면 새로운 기능을 만드는 것보다 테스트를 만드는 데 시간을 더 쓰게 되기 때문이다.

맥락에 따라 테스트 피라미드에 포함되는 계층은 달라질 수 있다.
육각형 아키텍처를 테스트하기 위해 내가 선택한 계층들을 한번 살펴보자. '단위 테스트' , '통합 테스트' , '시스템 테스트' 의
정의는 맥락에 따라 다르다는 것을 알아두자.
프로젝트마다 다른 의미를 가질 수 있다는 것이다. 다음의 정의는 이번 장에서 사용하는 의미다.

단위 테스트는 피라미드의 토대에 해당한다. 일반적으로 하나의 클래스를 인스턴스화하고 해당 클래스의 인터페이스를 통해
기능들을 테스트한다. 만약 테스트 중인 클래스가 다른 클래스에 의존한다면 의존되는 클래스들은 인스턴스화 하지 않고 테스트 하는 동안
필요한 작업들을 흉내 내는 목(mock)으로 대체한다.

피라미드의 다음 계층은 통합 테스트다. 이 테스트는 연결된 여러 유닛을 인스턴스화하고 시작점이 되는 클래스의 인터페이스로 데이터를
보낸 후 유닛들의 네트워크가 기대한 대로 잘 동작하는지 검증한다.

시스템 테스트 위에는 애플리케이션의 UI를 포함하는 엔드투엔드 (ent-to-end) 테스트 층이 있을 수 있다. 
하지만 이 책에서는 백엔드 아키텍처에 대해서 논의 하고 있으므로 엔드투엔드 테스트에 대해서는 고려하지 않기로 한다.


### 단위테스트로 도메인 엔티티 테스트하기

먼저 육각형 아키텍처의 중심인 도메인 엔티티를 살펴보자. 
4장에서 본 Account 엔티티를 떠올려보자. Account 의 상태는 과거 특정 지점의 계좌 잔고(baselineBalance)와 그 이후의
입출금 내역(activity)로 구성돼 있다. withdraw() 메서드가 기대한 대로 동작하는지 검증해보자.

```java
  @Test
    void widthdrawalSucceeds() {
        AccountId accountId =  new AccountId(1L);
        Account account = defaultAccount()
                .withAccountId(accountId)
                .withBaselineBalance(Money.of(555L))
                .withActivityWindow(new ActivityWindow(
                        defaultActivity()
                                .withTargetAccount(accountId)
                                .withMoney(Money.of(999L)).build(),
                        defaultActivity()
                                .withTargetAccount(accountId)
                                .withMoney(Money.of(1L)).build()
                ))
                .build();

        boolean success = account.withdraw(Money.of(555L), new AccountId(99L));

        assertThat(success).isTrue();
        assertThat(account.getActivityWindow().getActivities()).hasSize(3);
        assertThat(account.calculateBalance()).isEqualTo(Money.of(1000L));

    }
```

위 코드는 특정 상태의 Account 를 인스턴스화하고 withdraw() 매서드를 호출해서 출금을 성공했는지 검증하고, 
Account 객체의 상태에 대해 기대되는 부수효과들이 잘 일어났는지 확인하는 단순한 단위 테스트다.

이 테스트는 만들고 이해하는 것도 쉬운 편이고, 아주 빠르게 실행된다. 테스트가 이보다 간단할 수는 없다.
이런 식의 단위 테스트가 도메인 엔티티에 녹아 있는 비즈니스 규칙을 검증하기에 가장 적절한 방법이다. 
도메인 엔티티의 행동은 다른 클래스에 거의 의존하지 않기 때문에 다른 종류의 테스트는 필요하지 않다.

### 단위 테스트로 유스케이스 테스트하기

계층의 바깥쪽으로 나가서, 다음으로 테스트할 아키텍처 요소는 유스케이스다. 

SendMoney 유스케이스는 출금 계좌의 잔고가 다른 트랜잭션에 의해 변경되지 않도록 락(lock)을 건다.
출금 계좌에서 돈이 출금되고 나면 똑같이 입금 계좌에 락을 걸고 돈을 입금시킨다. 그러고 나서 두 계좌에서 모두 
락을 해제한다.

다음 코드는 트랜잭션이 성공했을 때 모든 것이 기대한 대로 동작하는지 검증한다.

