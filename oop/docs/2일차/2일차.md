# 2일차  2024-04-02 (p.29 ~ )


## 객체 지향

### 절차 지향과 객체 지향

#### 절차 지향

소프트웨어를 구현한다는 것은 결국 최종적으로는 소프트웨어를 구성하는 데이터와 데이터를 조작하는 코드를 작성하는 것이다.

데이터를 조작하는 코드를 별도로 분리해서 함수나 프로시저와 같은 형태로 만들고, 각 프로시저들이 데이터를 조작하는 방식으로 코드를 작성할 수 있을 것이다.

프로시저는 다른 프로시저를 사용할 수도 있고, 각각의 프로시저가 같은 데이터를 사용할 수도 있다. 

이렇게 프로시저(procedure)로 프로그램을 구성하는 기법을 절차 지향(Procedural Oriented) 프로그래밍이라고 부른다. 


![img.png](img.png)

각 프로시저는 데이터를 사용해서 기능을 구현하며, 필요에 따라 다른 프로시저를 사용하기도 한다. 또한, 여러 프로시저가 동일한 데이터를 공유한다. 


시험 성적 관리 프로그램을 생각 해보자

- 평균 계산 프로시저 
- 화면 출력 프로시저

여기서 평균 계산 프로시저와 화면 출력 프로시저는 데이터를 공유해서 사용한다. 

다수의 프로시저들이 데이터를 공유하는 방식으로 만들어지기 때문에, 절차 지향 프로그램은 자연스럽게 데이터를 중심으로 구현하게 된다. 


데이터와 그 데이터를 사용하는 프로시저를 작성하는 것은 자연스러운 과정이기 때문에, 최초에 절차 지향적으로 코드를 구현하는 것은 쉽다.

하지만, 프로그램 규모가 커져서 데이터 종류가 증가하고 이를 사용하는 프로시저가 증가하게 되면 , 다음과 같은 문제들이 발생하게 된다.


- 데이터 타입이나 의미를 변경해야 할 때, 함께 수정해야 하는 프로시저가 증가한다.
- 같은 데이터를 프로시저들이 서로 다른 의미로 사용하는 경우가 발생한다.

한 데이터를 사용하는 프로시저가 많아질수록 그 데이터의 타입을 변경하기 어려워진다. 예를 들어, 전자 장비의 꺼짐/켜짐 상태를 저장하기 위해
boolean 타입이고 이름이 isOn이라는 데이터를 사용한다고 가정하자.

이 데이터를 사용하는 프로시저는 모두 isOne 을 boolean 타입으로 처리 할 거이다. 그런데, 요구 사항이 변경되어서 
꺼짐/켜짐 상태 뿐만 아니라 대기 상태를 추가해야 한다고 해보자. 


이 요구 사항을 반영하기 위해 isOn 데이터의 타입을 boolean 타입에서 열거 타입으로 변경하게 되면, 이 데이터를 사용하는 모든 프로시저도 함께
수정해 주어야 한다.


이것보다 더 안좋은 경우는 프로그램 규모가 커질수록 같은 데이터를 서로 다른 의미로 사용하는 경우가 발생할 가능성이 높다는 것이다.
최초에 서비스 만료일 데이터가 null인 경우 이를 오유로 처리하도록 만료 확인 프로시저를 만들었는데, 회원 정보 수정 프로시저에서 서비스를 무한정
사용한다는 의미로 서비스 만료일 데이터의 값을 null 로 설정할 수 있다. 이 경우, 만료 확인 프로시저는 잘못 들어간 null 값 때문에 
예기치 않은 오류를 발생하게 될 것이다. 

앞의 두 경우는 단순한 예제이긴 하지만, 절차 지향적으로 프로그램을 구성할 때 매우 흔하게 발생되는 문제들이다. 
이로 인해 새로운 요구 사항이 생겨서 프로그램의 한 곳을 수정하게 되면, 다른 곳에서 문제가 발생하고, 다시 그곳을 수정하면 또 다른 곳에서
문제가 발생하는 악순환이 발생하기도 한다. 이는 결국 코드의 수정을 어렵게 만들며, 새로운 기능을 추가하는 데 많은 구현 시간을 투입하게 만든다.


#### 객체 지향


절차 지향과 달리 객체 지향은 데이터 및 데이터와 관련된 프로시저를 객체라고 불리는 단위로 묶는다.

객체는 프로시저를 실행하는데 필요한 만큼의 데이터를 가지며, 객체들이 모야 프로그램을 구성한다.

![img_1.png](img_1.png)


각 객체는 자신만의 데이터와 프로시저를 갖는다. 객첸느 자신만의 기능을 제공하며, 각 객체들은 서로 연결되어 다른 객체가 제공하는 기능을 사용할 수 있게 된다.

객체는 다른 객체에 기능을 제공하기 위해 프로시저를 사용하는데, 이때 프로시저는 자신이 속한 객체의 데이터에만 접근할 수 있으며, 
다른 객체에 속한 데이터에는 접근할 수 없다.


모든 프로시저가 데이털르 공유하는 절차 지향과 달리 객체 지향은 객체 별로 데이터와 프로시저를 알맞게 정의해야 하고, 앞서 1장에서 봤던
예제 처럼 프로그램의 규모가 작을 때엔느 절차 지향 방식보다 복잡한 구조를 갖게 된다. (즉, 절차 지향적으로 설계하는 것 보다 객체지향 적으로 설계하는 것이 더 어렵다.)

하지만, 객체 지향적으로 만든 코드에서는 객체의 데이터를 변경하더라도 해당 객체로만 변화가 집중되고 다른 객체에는 영향을 주지 않기 때문에,
요구 사항의 변화가 발생했을 때 절차 지향 방식 보다 프로그램을 더 쉽게 변경할 수 있는 장점을 갖는다. 


소프트웨어가 계속 사용되는 한 소프트웨어에 요구되는 기능은 계속 바뀐다. 그런데, 절차지향은 처음에는 쉬울지 몰라도 시간이 흐를수록 프로그램을 수정하기 어렵게
만드는 구조이기 때문에 변화된 요구 사항을 반영하기가 힘들어진다. 반면에 객체 지향은 최초에는 객체지향적으로 설계하는 데 더 많은 노력이 
들어갈 수 있지만 프로그램을 상대적으로 쉽게 수정할 수 있는 유연함을 제공하기 때문에, 변화된 요구 사항으 빠르게 반영할 수 있도록 만들어준다.

###  객체 (Object)

#### 객체의 핵심은 기능을 제공하는 것

객체 지향의 가장 기본은 객체다. 앞서 객첸느 데이터와 그 데이터를 조작하는 프로시저(오퍼레이션, 메서드 ,함수)로 구성된다고 했는데,

이는 객체의 물리적인 특징일 뿐이다. 실제로 객체를 정의할 때 사용되는 것은 객체가 제공해야 할 기능이며, 객체가 내부적으로 어떤 데이터를 
갖고 있는 지로는 정의되지 않는다.

예를 들어, 소리 크기 제어 객체가 있다고 하자. 이 객체는 소리 크기를 제어하는 기능을 제공하며, 아마도 이 객체가 제공하는 기능은 다음과 같을 것이다.

- 소리 크기 증가
- 소리 크기 감소
- 음 소거

이 객체가 내부적으로 소리 크기를 어떤 데이터 타입 값으로 보관하는지는 중요하지 않다. 
또한, 실제로 객체가 어떻게 소리 크기를 증가시키거나 감소시키는지는 알 수 없다. 단지, 소리 크기 제어 객체는
'소리 크기 증가' , '소리 크기 감소', '음 소거' 라는 세 개의 기능을 제공한다는 것이 중요할 뿐이다. 

#### 인터페이스와 클래스 

객체는 객체가 제공하는 기능으로 정의된다.  보통 객체가 제공하는 기능을 오퍼레이션이라고 부른다.
즉 , 객체는 오퍼레이션으로 정의가 된다. 
객체가 제공하는 기능을 사용한다는 것은 결국 객체의 오퍼레이션을 사용한다는 의미가 된다.
그런데, 객체가 제공하는 오퍼레이션을 사용할 수 있으려면, 그 오퍼레이션의 사용법을 알아야 한다.

오퍼레이션의 사용법은 일반적으로 다음과 같이 세 개로 구성되며, 이 세 가지를 합쳐서 시그니처(Signature)라고 부른다.

- 기능 식별 이름
- 파라미터 및 파라미터 타입
- 기능 실행 결과 값

객체가 제공하는 모든 오퍼레이션 집합을 객체의 '인터페이스(interface) ' 라고 부르며, 서로 다른 인터페이스를 구분할 때
 사용되는 명칭이 바로 타입(type)이다. 여기서 말하는 인터페이스는 자바 언어나 C# 언어에 포함되어 있는 인터페이스가 아니라, 객체 지향에서
오퍼레이션 집합을 표현할 때 사용되는 용어다. 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙이라고 생각하면 된다.

인터페이스는 객체가 제공하는 기능에 대한 명세서일 뿐, 실제 객체가 기능을 어떻게 구현하는지에 대한 내용은 포함하고 있지 않다.
실제 객체의 구현을 정의하는 것은 클래스(class)이다.

이 클래스에는 오퍼레이션을 구현하는 데 필요한 데이터 및 오퍼레이션의 구현이 포함된다. 


#### 메시지

객체 지향은 기능을 제공하는 여러 객체들이 모여서 완성된 어플리케이션을 구성하게 된다. 
예를 들어, 파일에서 데이터를 읽어 오는 객체가 있고, 데이터를 암호화 해주는 객체가 있고, 파일에 데이터를 쓰는 객체가 있다고 하자.

이 경우, 특정 파일에서 데이터를 읽어 와 암호화 한 뒤에 다른 파일에 쓰는 프로그램은 세 개의 객체로 구성된다.

![img_2.png](img_2.png)


이 경우 , 암호화 처리 객체는 파일 읽기 객체에게 read 오퍼레이션을 실행해달라는 요청을 전달하며, 
요청을 받은 파일 읽기 객체는 해당 요청에 해당 하는 기능을 실행한 뒤에 응답을 전달 하게 된다.

이때 , 오퍼레이션의 실행을 요청 하는 것을 '메시지'를 보낸다. 고 표현한다.

### 객체의 책임과 크기 

객체는 객체가 제공하는 기능으로 정의된다고 했는데, 이는 다시 말하면 객체마다 자신만의 책임이 있다는 의미를 갖는다. 

한 객체가 갖는 책임을 정의한 것이 바로 타입/인터페이스라고 생각하면 된다. 

- 암호화 처리 객체
  - 제공받은 데이터를 암호화해서 다른 파일에 보내는 책임
- 파일 읽기 객체
  - 파일에서 데이터를 읽어와 제공하는 책임
- 파일 쓰기 객체
  - 파일에 데이터를 쓰는 책임

세 개의 객체가 서로 다른 책임을 지는데, 이런 책임 할당이 처음부터 바로 결정된 것은 아니다. 
처음에는 프로그램을 만들기 위해 필요한 기능 목록을 정리해야 한다. 

기능 목록을 정리한 예

- 파일의 byte 데이터를 제공한다.
- 파일에 byte 데이터를 쓴다.
- byte 데이터를 암호화해서 새로운 byte 데이터를 생성한다.
- 전체 흐름을 제어한다.

객체 지향적으로 프로그래밍할 때 , 가장 어려우면서 가장 중요한 것이 바로 객체마다 기능을 할당하는 과정이다. 기능이 몇 개 안 되는 경우에도
다양한 조합의 구성이 가능하기 때문에, 이런 다양한 조합 중에서 알맞은 구성을 찾아내는 것은 쉽지 않다. 

상황에 따라 객체가 가져야 할 기능의 종류와 개수가 달라지기 때문에, 모든 상황에 들어맞는 객체-책임 구성 규칙이 존재하는 것은 아니다.
하지만, 객체가 얼마나 많은 기능을 제공할 것인가에 대한 확실한 규칙이 하나 존재하는데, 그 규칙은 바로 객체가 갖는 책임의 크기는
작으면 작을수록 좋다는 것이다. 객체가 갖는 책임이 작아야 한다는 것은 객체가 제공하는 기능의 개수가 적다는 걸 의미한다.


만약에 객체가 제공하는 기능의 개수가 많아 지면 그 기능과 관련된 데이터들도 한 객체에 모두 포함된다. 
이 구조는 객체에 정의된 많은 오퍼레이션들이 데이터들을 공유하는 방식으로 프로그래밍된다는 것을 의미하는데, 이는 곧 데이터를 
중심으로 개발되는 절차 지향 방식과 동일한 구조가 된다. 따라서 객체가 갖는 책임이 커질수록 절차 지향적으로 구조가 변질되며,
절차 지향의 가장 큰 단점인 기능 변경의 어려움 문제(즉, 경직성 문제)가 발생하게 된다.

따라서 객체가 갖는 책임의 크기는 작아질수록 객체 지향의 장점인 변경의 유연함을 얻을 수 있게 된다.
객체의 크기와 관련된 원칙이 있는데 그 원칙은 바로 단일 책임 원칙이다. 단일 책임 원칙은 이름에서 알 수 있듯이
객체는 단 한개의 책임만을 가져야 한다는 원칙이다. 이 원칙에 따르면 객체 구조는 네 개의 객체가 각각 한 개의 책임만을 갖도록 재구성 된다.

- 흐름 제어
- 파일 읽기
- byte 암호화
- 파일 쓰기

단일 책임 원칙을 따르다 보면 자연스럽게 기능의 세부 내용이 변경 될 때, 변경해야 할 부분이 한 곳으로 집중된다.

예를 들어, 파일을 읽어 오는 방법을 변경해야 한다면 '파일 읽기' 책임을 가진 객체의 코드만 수정되며, 다른 객체의 코드를 수정해야 할 가능성은
낮아진다. 비슷하게 암호화 알고리즘을 변경해야 할 경우. 'byte 암호화' 객체의 코드만 변경될 뿐 다른 객체의 코드가 변경될 가능성은 줄어든다.
즉, 단일 책임 원칙은 변경의 유연함을 얻기 위한 가장 기본 원칙이 된다.

