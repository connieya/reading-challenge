# 5일차 p.36 ~ 

## 다 쓴 객체 참조를 해제하라

자바의 가비지 컬렉터 때문에 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해 할 수 있는데,
절대 사실이 아니다.

`메모리 누수가 일어나는 위치는 어디인가? `

```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        return elements[--size];
    }

    private void ensureCapacity() {
        if (elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
}
```

위의 코드에서 발생할 수 있는 문제는 '메모리 누수'로, 
이 스택을 사용하는 프로그램을 오래 실행하다 보면 점차 가비지 컬렉션 활동과 메모리 사용량이 늘어나 결국 성능이 저하 될 것이다.

상대적으로 드문 경우긴 하지만 심할 때는 디스크 페이징이나 OutOfMemoryError 를 일으켜 프로그램이 예기치 않게 종료되기도 한다. 

여기서 메모리 누수는 어디서 일어날까? 
이 코드에서는 스택이 커졌다가 줄어들었을 때 스택에서 꺼내진 객체들을 가비지 컬렉터가 회수 하지 않는다. 
프로그램에서 그 객체들을 더 이상 사용하지 않더라도 말이다.

이 스택이 그 객체들의 다 쓴 참조를 여전히 가지고 있기 때문이다.
여기서 다 쓴 참조란 문자 그대로 앞으로 다시 쓰지 않을 참조를 뜻한다. 

앞의 코드에서는 elemetns 배열의 '활성 영역'밖의 참조들이 모두 여기에 해당한다.

활성 영역은 인덱스가 size 보다 작은 원소들로 구성된다.

가비지 컬렉션 언어에서는 (의도치 않게 객체를 살려두는) 메모리 누수를 찾기가 아주 까다롭다.
객체 참조 하나를 살려두면 가비지 컬렉터는 그 객체 뿐 아니라 그 객체가 참조하는 모든 객체를 회수해가지 못한다. 
그래서 단 몇개의 객체가 매우 많은 객체를 회수되지 못하게 할 수 있고 잠재적으로 성능에 악영향을 줄 수 있다.

해법은 간단하다. 해당 참조를 다 썼을 때 null(참조 해제) 처리 하면 된다.

예시의 스택 클래스에서는 각 원소의 참조가 더 이상 필요 없어지는 시점은 스택에서 꺼내질 때다. 

다음은 pop 메서드를 제대로 구현한 모습이다.

`제대로 구현한 pop 메서드`

```java
    public Object pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        Object result =  elements[--size];
        elements[size] = null;
        return result;
    }
```

다 쓴 참조를 null 처리하면 다른 이점도 따라온다. 만약 null 처리한 참조를 실수로 사용하려 하면
프로그램은 즉시 NullPointerException 을 던지며 종료 된다. 

프로그램 오류는 가능한 한 조기에 발견하는 게 좋다.

이 문제로 크게 데인 적이 있는 프로그래머는 모든 객체를 다 쓰자마자 일일이 null 처리 하는 데 혈안이 되기도 한다. 
하지만 그럴 필요도 없고 바람직하지도 않다. 프로그램을 필요 이상으로 지저분하게 만들 뿐이다. 

객체 참조를 null 처리 하는 일은 예외적인 경우여야 한다. 다 쓴 참조를 해제하는 가장 좋은 방법은 
그 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다. 

여러분이 변수의 범위를 최소가 되게 정의했다면 이 일은 자연스럽게 이뤄진다.

그렇다면 null 처리는 언제 해야 할까? Stack 클래스는 왜 메모리 누수에 취약한 걸까?

바로 스택이 자기 메모리를 직접 관리하기 때문이다. 

이 스택은 (객체 자체가 아니라 객체 참조를 담는) elements 배열로 저장소 풀을 만들어 
원소들을 관리한다. 배열의 활성 영역에 속한 원소들이 사용되고 비활성 영역은 쓰이지 않는다.

문제는 가비지 컬렉터는 이 사실을 알 길이 없다는 데 있다.
가비지 컬렉터가 보기에는 비활성 영역에서 참조하는 객체도 똑같이 유효한 객체다.

비활성 영역의 객체가 더 이상 쓸모 없다는 건 프로그래머만 아는 사실이다.
그러므로 프로그래머는 비활성 영역이 된느 순간 null 처리해서 해당 객체를 더는 쓰지 않을 것임으로 가비지 컬렉터에 알려야 한다.

일반적으로 자기 메모리를 직접 관리한느 클래스라면 프로그래머는 항시 메모리 누수에 주의해야 한다.

원소를 다 사용한 즉시 그 원소가 참조한 객체들을 다 null 처리해줘야 한다.

캐시 역시 메모리 누수를 일으키는 주범이다.

객체 참조를 캐시에 넣고 나서, 이 사실을 까맣게 잊은 채 그 객체를 다 쓴 뒤로도 한참을 그냥 놔두는 일을 자주 접할 수 있다.
해법은 여러 가지다. 운 좋게 캐시 외부에서 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면
WeakHashMap 을 사용해 캐시를 만들자. 

다 쓴 엔트리는 그 즉시 자동으로 제거될 것이다. 

단, WeakHashMap 은 이러한 상황에서만 유용하다는 사실을 기억하자.

캐시를 만들 때 보통은 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어뜨리는 
방식을 흔히 사용한다. 이런 방식에서는 쓰지 않는 엔트리를 이따금 청소해줘야 한다. 

