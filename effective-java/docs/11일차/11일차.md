# 11일차  2024-05-02 p.77 ~

## 아이템 13 clone 재정의는 주의해서 진행하라

Cloneable 은 복제해도 되는 클래스 임을 명시하는 용도의 믹스인 
인터페이스지만, 아쉽게도 의도한 목적을 제대로 이루지 못했다.

가장 큰 문제는 clone 메서드가 선언된 곳이 Cloneable 이 아닌 
Object 이고, 그마저도 protected 라는 데 있다.

그래서 Cloneable 을 구현하는 것만으로는 외부 객체에서 clone 메서드를
호출할 수 없다.

리플랙션을 사용하면 가능하지만, 100% 성공하는 것도 아니다.
해당 객체가 접근이 허용된 clone 메서드를 제공한다는 보장이 없기 때문이다.
하지만 이를 포함한 여러 문제점에도 불구하고 Cloneable 방식은 널리 쓰이고 있어서
잘 알아두는 것이 좋다.

메서드 하나 없는 Cloneable 인터페이스는 대체 무슨 일을 할까?
이 인터페이스는 놀랍게도 Object 의 protected 메서드인 clone 의 동작 방식을
결정 한다. Cloneable 을 구현한 클래스의 인스턴스에서 clone 을 호출하면 그 객체의 필드들을 하나하나 복사한 객체를
반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportedException 을 던진다. 

이는 인터페이스를 상당히 이례적으로 사용한 예이니 따라 하지는 말자

인터페이스를 구현한다는 것은 일반적으로 해당 클래스가 그 인터페이스에서
정의한 기능을 제공한다고 선언하는 행위다. 그런데 Cloneable 의 경우에는
상위 클래스에 정의된 protected 메서드의 동작 방식을 변경한 것이다.

명세에서는 이야기 하지 않지만 실무에서 Cloneable 을 구현한 클래스는 
clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대한다.

이 기대를 만족시키려면 그 클래스와 모든 상위 클래스는 복잡하고, 
강제할 수 없고, 허술하게 기술된 프로토콜을 지켜야만 하는데, 그 결과로
깨지기 쉽고, 위험하고, 모순적인 메커니즘이 탄생한다. 생성자를 호출하지 않고도
객체를 생성할 수 있게 된 것이다.

clone 메서드의 일반 규약은 허술하다. Object 명세에서 가져온 다음 설명을 보자

> 이 객체의 복사본을 생성해 반환한다. '복사'의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있다.
> 일반적인 의도는 다음과 같다. 어떤 객체 x에 대해 다음 식은 참이다.
> <br/>
> x.clone() != x
> <br/>
> 또한 다음 식도 참이다.
> <br/>
> <br/>
> x.clone().getClass() == x.getClass()
> <br/>
> 하지만 이상의 요구를 반드시 만족해야 하는 것은 아니다. <br/>
> 한편 다음 식도 일반적이므로 참이지만, 역시 필수는 아니다. <br/>
> x.clone().equals(x)

강제성이 없다는 점만 빼면 생성자 연쇄와 살짝 비슷한 메커니즘이다.
즉, clone 메서드가 super.clone 이 아닌, 생성자를 호출해 얻은 인스턴스를 
반환해도 컴파일러는 불평하지 않을 것이다.
하지만 이 클래스의 하위 클래스에서 super.clone 을 호출한다면
잘못된 클래스의 객체가 만들어져, 결국 하위 클래스의 clone 메서드가
제대로 동작하지 않게 된다.  clone 을 재정의한 클래스가 final
 이라면 걱정해야 할 하위 클래스가 없으니 이 관례는 무시 해도 안전하다.
하지만 final 클래스의 clone 메서드가 super.clone 을 호출하지 않는다면
Cloneable 을 구현할 이유도 없다. Object 의 clone 구현의
동작 방식에 기댈 필요가 없기 때문이다.


제대로 동작하는 clone 메서드를 가진 상위 클래스를 상속해 
Cloneable 을 구현하고 싶다고 해보자. 
먼저 super.clone 을 호출한다. 
그렇게 얻은 객체는 원본의 완벽한 복제본일 것이다.
클래스에 정의된 모든 필드는 원본 필드와 똑같은 값을 갖는다.

모든 필드가 기본 타입이거나 불변 객체를 참조한다면 이 객체는
완벽히 우리가 원하는 상태러 더 손볼 것이 없다.

쓸데 없는 복사를 지양한다는 관점에서 보면 불변 클래스는 굳이 clone 메서드를 
제공하지 않는 게 좋다. 이 점을 고려해 PhoneNumber 의 clone 메서드는 다음처럼 구현할 수 있다.


```java
@Override public PhoneNumber clone() {
    try {
        return (PhoneNumber) super.clone();    
    }catch (CloneNotSupportdException e) {
        throw new AssertionError();
    }    
}
```