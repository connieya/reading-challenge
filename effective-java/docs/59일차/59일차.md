# 59일차 2024-06-19  p.358 ~ 361

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라 

자바의 데이터 타입은 크게 두 가지로 나눌 수 있다. 바로 int , double, boolean 같은 기본 타입과 
String , List 같은 참조 타입이다. 
그리고 각각의 기본 타입에는 대응하는 참조 타입이 하나씩 있으며, 이를 박싱된 기본 타입이라고 한다. 

예컨대 int ,double , boolean 에 대응하는 박싱된 기본 타입은 Integer, Double , Boolean 이다.

아이템 6에서 이야기했듯, 오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만 , 
그렇다고 차이가 사라지는 것은 아니다. 둘 사이에는 분명한 차이가 있으니 어떤 타입을 사용하는지는 상당히 중요하다.
주의해서 선택해야 한다는 말이다.

기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세 가지다. 첫 번째, 기본 타입은 값만 가지고 있으나, 
박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다.
달리 말하면 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다. 

두 번째, 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, 즉 null 을 가질 수 있다. 

세 번째, 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다. 
이상의 세가지 차이 때문에 주의하지 않고 사용하면 진짜로 문제가 발생할 수 있다. 

다음은 Integer 값을 오름차순으로 정렬하는 비교자다.  
(복습해보자 비교자의 compare 메서드는 첫 번째 원소가 두 번째 원소보다 작으면 음수, 같으면 0, 크면 양수를 반환한다.)
Integer 는 그 자체로 순서가 있으니 이 비교자가 실절적인 의미는 없지만, 아주 흥미로운 점을 하나 보여준다. 

`코드 61-1 잘못 구현된 비교자 - 문제를 찾아보자 !`

```java
import java.util.Comparator;

Comparator<Integer> naturalOrder =
        (i , j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```
별다른 문제를 찾기 어렵고, 실제로 이것 저것 테스트해봐도 잘 통과한다. 
예컨대 Collection.sort 에 원소 백만 개 짜리 리스트와 이 비교자르 넣어 돌려도 아무 문제가 없다. 
리스트에 중복이 있어도 상관 없다. 하지만 심각한 결함이 숨어 있으니... , 이 결함을 눈으로 확인하고 싶다면 
naturalOrder.compare(new Integer(42) , new Integer(42)) 의 값을 출력해보자. 
두 Integer 인스턴스의 값이 42로 같으므로 0을 출력해야 하지만, 실제로는 1을 출력한다. 
즉, 첫번 째 Integer 가 두 번째보다 크다고 주장한다.



이처럼 (같은 객체를 비교하는 게 아니라면 ) **박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.**

실무에서 이와 같이 기본 타입을 다루는 비교자가 필요하다면 Comparator.naturalOrder() 를 사용하자.
비교자를 직접 만들면 비교자 생성 메서드나 기본 타입을 받는 정적 compare 메서드를 사용해야 한다. 
그렇더라도 이 문제를 고치려면 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본 타입 정수로 저장한 다음,
모든 비교를 이 기본 타입 변수로 수행해야 한다. 이렇게 하면 오류의 원인인 식별성 검사가 이뤄지지 않는다. 

`코드 61-2 문제를 수정한 비교자 `

```java
import java.util.Comparator;

Comparator<Integer> naturalOrder = (iBoxed , jBoxed) -> {
    int i = iBoxed , j = jBoxed; // 오토 박싱
    return  i < j ? -1 : (i==j ? 0 : 1); 
};
```

이제 다음의 간단한 프로그램을 살펴보자

`코드 61-3 기이하게 동작하는 프로그램 - 결과를 맞혀보자 !`

```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42)
            System.out.println("믿을 수 없군");
    }
}
```

그렇다면 박싱된 기본 타입은 언제 써야 하는가? 적절히 쓰이는 경우가 몇 가지 있다.

마지막으로, 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.


> **핵심 정리**
> <br/>
> 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라.
> 기본 타입은 간단하고 빠르다. 박싱된 기본 타입을 써야 한다면 주의를 기울이자.
> 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.
> 두 박싱된 기본 타입을 == 연산자로 비교한다면 식별성 비교가 이뤄지는데, 이는 여러분이 원한 게 아닐 가능성이 크다.
> 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 언박싱 과정에서 NullPointerException 
> 을 던질 수 있다. 마지막으로, 기본 타입을 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있다. 
