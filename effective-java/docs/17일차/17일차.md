# 17일차 2024-05-08 p.122 ~ 129

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라


**상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.**

('재정의 가능'이란 public 과 protected 메서드 중 final 이 아닌 모든 메서드를 뜻한다.)
더 넓게 말하면, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다. 
예를 들어 백그라운드 스레드나 정적 초기화 과정에서도 호출이 일어날 수 있다.

클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.

효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 **클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 
잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.**


상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야 할지는 어떻게 결정할까?
안타깝게도 마법은 없다. 심사숙고해서 잘 예측해본 다음, 
실제 하위 클래스를 만들어 시험해보는 것이 최선이다.

protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 적어야 한다. 
한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다.

**상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어 보는 것이 '유일' 하다.**
꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러난다.
거꾸로, 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private 이었어야 할 가능성이 크다.
경험상 이러한 검증에는 하위 클래스 3개 정도가 적당하다. 그리고 이 중 하나 이상은 제 3자가 작성해봐야 한다.


널리 쓰일 클래스를 상속용으로 설계한다면 여러분이 문서화한 내부 사용 패턴과 , protected 메서드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 함을
잘 인식해야 한다.
이 결정들이 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있다.
그러니 **상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.**

또한, 상속하려는 사람을 위해 덧붙인 설명은 단순히 그 클래스의 인스턴스만 만들어 사용할 프로그래머에게는 필요 없는 군더더기일 뿐이다.

상속을 허용하는 클래스가 지켜야 할 제약이 아직 몇 개 남았다.
**상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.**

이 규칙을 어기면 프로그램이 오동작할 것이다. 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로
하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다. 
이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작하지 않을 것이다.

```java
public class Super {
    
    public Super() {
        // 잘못된 예 - 생성자가 재정의 가능 메서드르 호출한다.
        overrideMe();
    }

    public void overrideMe() {
    }
}

```

다음은 하위 클래스의 코드로, overrideMe 메서드를 재정의했다. 상위 클래스의 생성자가 호출해 오동작을 일으키는 바로 그 메서드다.

```java
public final class Sub extends Super {

    private final Instant instant;

    Sub() {
        instant = Instant.now();
    }

    @Override
    public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}

```

이 프로그램이 instant 를 두 번 출력하리라 기대했겠지만, 첫 번째는 null 을 출력한다.
상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 overrideMe 를 호출하기 때문이다.
final 필드의 상태가 이 프로그램에서는 두 가지임에 주목하자
overrideMe 에서 instant 객체의 메서드를 호출하려 한다면 상위 클래스의 생성자가 overrideMe를 호출할 때
NullPointerException을 던지게 된다. 이 프로그램이 NullPointerException 을 던지지 않은 유일한 이유는
println 이 null 입력도 받아들이기 때문이다.

> private , final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다.

Cloneable 과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다.
둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다.
그 클래스를 확장하려는 프로그래머에게 엄청난 부담을 지우기 때문이다.

clone 과 readObject 메서드는 생성자와 비슷한 효과를 낸다. 
따라서 상속용 클래스에서 Cloneable 이나 Serializable 을 구현할 지 정해야 한다면,
이들을 구현할 때 따르는 제약도 생성자와 비슷하다는 점에 주의하자.
즉, **clone 과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다.**

readObject 의 경우 하위 클래스의 상태가 미처 다 역직렬화되기 전에 재정의한 메서드부터 호출하게 된다.
clone 의 경우 하위 클래스의 clone 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출한다.

**클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약도 상당함을 알았다.**

그렇다면 그 외의 일반적인 구체 클래스는 어떨까? 전통적으로 이런 클래스는 final 도 아니고
상속용으로 설계되거나 문서화되지도 않았다. 하지만 그대로 두면 위험하다. 클래스에 변화가 생길 때마다
하위 클래스를 오동작하게 만들 수 있기 때문이다. 실제로도 보통의 구체 클래스를 그 내부만 수정했음에도 이를 확장한 클래스에서
문제가 생겼다는 버그 리포트를 받는 일이 드물지 않다. 

이 문제를 해결하는 가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.

상속을 금지하는 방법은 두 가지다. 둘 중 더 쉬운 쪽은 클래스를 final 로 선언하는 방법이다.
두 번째 선택지는 모든 생성자를 private 이나 package-private 으로 선언하고 public 정적 팩토리를 만들어주는 방법이다.
정적 팩토리 방법은 내부에서 다양한 하위 클래스를 만들어 쓸 수 있는 유연성을 준다.

구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해진다. 
이런 클레스라도 상속을 꼭 허용해야겠다면 합당 한 방법이 하나 있다.
클래스 내부에서는 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서로 남기는 것이다.
재정의 가능 메서드를 호출하는 자기 사용 코드를 완벽히 제거하라는 말이다.
이렇게 하면 상속해도 그리 위험하지 않은 클래스를 만들 수 있다. 메서드를 재정의해도 다른 메서드의 동작에 
아무런 영향을 주지 않기 때문이다.

> **핵심 정리**
> <br/>
> 상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로를 어떻게 사용하는지
> (자기사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다.
> 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다.
> 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected 로 제공해야 할 수도 있다.
> 그러니 클래스를 확장해야 할 명호가한 이유가 떠오르지 않으면 상속을 금지하는 편이 나을 것이다.
> 상속을 금지하려면 클래스를 final 로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.