# 24일차 2024-05-15 p.153 ~ 159

## 5장 제네릭

제네릭은 자바 5로 부터 사용할 수 있다. 제네릭을 지원하기 전에는 컬렉션에서
객체를 꺼낼 때마다 형변환을 해야 했다. 그래서 누군가 실수로 엉뚱한 타입의 객체를 넣어두면
런타임에 형변환 오류가 나곤 했다. 반면, 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 된다.
그래서 컴파일러는 알아서 형변환 코드를 추가할 수 있게 되고, 엉뚱한 타입의 객체를 넣으려는 시도를 컴파일 과정에서
차단하여 더 안전하고 명확한 프로그램을 만들어 준다.

## 아이템 26. 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다.
예컨대 List 인터페이스는 원소의 타입을 나타내는 타입 매개변수 E를 받는다. 그래서 이 인터페이스의 완전한 이름은
List<E> 지만, 짧게 그냥 List 라고도 자주 쓴다. 제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입이라 한다.

List<String> 은 원소틔 타입이 String 인 리스트를 뜻하는 매개변수화 타입이다. 여기서 String 이 정규 타입 매개변수
E에 해당하는 실제 타입 매개변수다.

마지막으로, 제네릭 타입을 하나 정의하면 그에 딸린 로 타입(raw type)도 함께 정의된다.
로 타입이란 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다.


`코드 26-1 컬렉션의 로 타입 - 따라 하지 말것 !`

```java
private final Collection stamps = ...;
```


이 코드를 사용하면 실수로 도장 대신 동전을 넣어도 아무 오류 없이 컴파일되고 실행된다.

`코드 26-2 반복자의 로 타입 - 따라 하지 말것`


오류는 가능한 한 발생 즉시, 이상적으로는 컴파일 할 때 발견하는 것이 좋다. 이 예에서는 오류가 발생하고
한참 뒤인 런타임에야 알아챌 수 있는데, 이렇게 되면 런타임에 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 상당히
떨어져 있을 가능성이 커진다.

`코드 26-3 매개변수화 된 컬렉션 타입 - 타입 안정성 확보!`

```java
private final Collection<Stamp> stamps = ...;
```

이렇게 선언하면 컴파일러는 stamps 에는 Stampe 의 인스턴스만 넣어야 함을 컴파일러가 인지하게 된다.
따라서 아무런 경고 없이 컴파일 된다면 의도대로 동작할 것임을 보장한다. 

물론 컴파일러 경고를 숨기지 않았어야 한다. 

이제 stamps 에 엉뚱한 타입의 인스턴스를 넣으려 하면 컴파일 오류가 발생하며 무엇이 잘못됐는지를 정확히 알려준다.

컴파이러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.

**로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 읽게 된다.**

List 같은 로 타입은 사용해서는 안 되나, List<Object> 처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다.
로 타입인 List 와 매개변수화 타입인 List<Object> 의 차이는 무엇일까? 
간단히 이야기하자면, List 는 제네릭 타입에서 완전히 발을 뺀 것이고, List<Object> 는 모든 타입을 허용한다는 의사를
컴파일러에 명확히 전달한 것이다.


매개변수로 List를 받는 메서드에 List<String> 을 넘길 수 있지만, List<Object> 를 받는 메서드에는 넘길 수 없다.
이는 제네릭의 하위 타입 규칙 때문이다. 즉, List<String> 은 로 타입인 List 의 하위 타입이지만, List<Object> 의 하위 타입은 아니다.

그 결과, **List<Object> 같은 매개변수화 타입을 사용할 때와 달리 List 같은 로 타입을 사용하면 타입 안정성을 잃게 된다.**


`코드 26.4 런타임에 실패한다. - unsafeAdd 메서드가 로 타입(List)을 사용`

```java
public static void main(String[] args) {
        List<String> strings = new ArrayList<>();
        unsafeAdd(strings,Integer.valueOf(42));
        String s = strings.get(0);
    }

    private static void unsafeAdd(List list , Object o){
        list.add(o);
    }
```

이 프로그램을 이대로 실행하면 strings.get(0)의  결과를 형변환하려 할 때 ClassCastException 을 던진다.


이쯤 되면 원소의 타입을 몰라도 되는 로 타입을 쓰고 싶어질 수 있다.
예컨대 2개의 집합을 받아 공통 원소를 반환하는 메소드를 작성한다고 해보자.

`코드 26-5 잘못된 예 - 모르는 타입의 원소도 받는 로 타입을 사용했다.`

```java
   static int numElementsInCommon(Set s1 ,Set s2) {
        int result = 0;
        for (Object o1 : s1){
            if (s2.contains(o1))
                result++;
        }
        return result;
    }
```

이 메서드는 동작은 하지만 로 타입을 사용해 안전하지 않다. 따라서 비한정적 와일드카드 타입을 대신 사용하는 게 좋다.
제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표(?) 를 사용하자.

예컨대 제네릭 타입인 Set<E> 의 비한정적 와일드카드 타입은 Set<?>다. 이것이 어떤 타입이라도 담을 수 있는
가장 범용적인 매개변수화 Set 타입이다.

다음은 비한정적 와일드카드 타입을 사용해 numElementsInCommon 을 다시 선언한 모습이다.

`코드 26-6 비한정적 와일드카드 타입을 사용하라 - 타입 안전하며 유연하다.`

```java
  static int numElementsInCommon(Set<?> s1 ,Set<?> s2) {
        int result = 0;
        for (Object o1 : s1){
            if (s2.contains(o1))
                result++;
        }
        return result;
    }
```

비한정적 와일드카드 타입인 Set<?> 와 로 타입인 Set의 차이는 무엇일까?
와일드카드 타입은 안전하고, 로 타입은 안전하지 않다.

로 타입 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다.

로 타입을 쓰지 말라는 규칙에도 소소한 예외가 몇 개 있다. class 리터럴에는 로 타입을 써야 한다.

자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했다. (배열과 기본 타입은 허용한다.)

예를 들어 List.class , String[].class , int.class 는 허용하고 List<String>.class 와 List<?>.class 는 허용하지 않는다.

두 번째 예외는 instanceof 연산자와 관련이 있다. 런타임에는 제네릭 타입 정보가 지워지므로 instaceof 연산자는 비한정적 와일드카드 타입 이외의
매개변수화 타입에는 적용할 수 없다. 그리고 로 타입이든 비한정적 와일드카드 타입이든 instanceof 는 완전히 똑같이 동작한다. 
비한정적 와일드카드 타입의  꺽쇠괄호와 물음표는 아무런 역할 없이 코드만 지저분하게 만드므로, 차라리 로 타입을 쓰는 편이 깔끔하다.


> **핵심 정리**
> <br/>
> 로 타입을 사용하면 런타임에 예외가 일어 날 수 있으니 사용하면 안 된다. 
> 로 타입은 제네릭이 도입하기 이전 코드와의 호환성을 위해 제공될 뿐이다. 
> 빠르게 훑어보자면, Set<Object> 는 어떤 타입의 객체도 저장할 수 있는 매개변수화타입이고,
> Set<?> 는 모종의 타입 개기체만 저장할 수 있는 와일드카드 타입이다. 
> 그리고 이들의 로 타입인 Set 은 제네릭 타입 시스템에 속하지 않는다. Set<Object> 와 Set<?> 는 안전하지만,
> 로 타입인 Set 은 안전하지 않다.