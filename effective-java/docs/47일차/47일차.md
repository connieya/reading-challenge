# 47일차 2024-06-07 p.297 ~ 301

## 8장 메서드

이번 장에서는 메서드를 설계할 때 주의할 점들을 살펴본다. 구체적으로는 매개변수와 반환값을 어떻게 처리해야 하는지,
메서드 시그니처는 어떻게 설계 해야 하는지, 문서화는 어떻게 해야 하는지를 다룬다. 

## 아이템 49. 매개변수가 유효한지 검사하라

메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 
예컨대 인덱스의 값은 음수이면 안 되며, 객체 참조는 null 이 아니어야 하는 식이다.
이런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다. 
이는 "오류는 가능한 빨리 잡아야 한다" 는 일반 원칙의 한 사례이기도 하다. 
오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기 어려워진다.

메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.
매개변수 검사를 제대로 하지 못하면 몇 가지 문제가 생길 수 있다.
첫 번째, 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다. 더 나쁜 상황은 메서드가 잘 수행되지만 
잘못된 결과를 반환할 때다. 한층 더 나쁜 상황은 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어놓아서 미래의 알 수 없는 시점에
이 메서드와는 관련 오류를 낼 때다. 다시 말해 매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있다.

public 과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화 해야 한다. 

매개변수의 제약을 문서화한다면 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다. 

이런 간단한 방법으로 API가 사용자가 제약을 지킬 가능성을 크게 높일 수 있다. 
다음은 전형적인 예다.

```java
// 함상 음이 아닌 BigInteger 를 반환한다는 점에서 remainder 메서드와 다르다.

import java.math.BigInteger;

public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0) 
        throw new ArithmeticException("계수 (m) 은 양수여야 합니다. "+m);
    // ....
}

```

이 메서드는 m 이 null 이면 m.signum() 호출 때 NullPointerException 을 던진다.

자바 7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기도 편하니, 더 이상 null 검사를 수동으로 하지 않아도 된다.


`코드 49-1 자바의 null 검사 기능 사용하기`

```java
import java.util.Objects;
this.strategy = Objects.requireNonNull(strategy , "전략";)
```

반환값은 그냥 무시하고 필요한 곳 어디서든 순수한 null 검사 목적으로 사용해도 된다.

공개되지 않은 메서드라면 패키지 제작자인 여러분이 메서드가 호출되는 상황을 통제할 수 있다.
따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 여러분이 보증할 수 있고, 그렇게 해야 한다.

다시 말해 public 이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다.

`코드 49-2 재귀 정렬용 private 도우미 함수`

```java
private static void sort(long a[] , int offset , int length) {
    assert a != null;
    assert  offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length -offset;
}
```
여기서의 핵심은 이 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다는 것이다. 
이 메서드가 포함된 패키지를 클라이언트가 어떤 식으로 지지고복든 상관없다. 단언문은 몇 가지 면에서 일반적인 유효성 검사와 다르다.
첫 번째, 실패하면 AssertionError 를 던진다. 두 번째, 런타임에 아무런 효과도, 아무런 성능 저하도 없다.

생성자는 "나중에 쓰려고 저장하는 매개변수의 유효성을 검사하라"는 원칙의 특수한 사례다. 
생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는 데 꼭 필요하다.

메서드 몸체 실행 전에 매개변수 유효성을 검사해야 한다는 규칙에도 예외는 있다.
유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때다.

> **핵심 정리**
> <br/>
> 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 한다. 
> 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다. 이런 습관을 반드시 기르도록 하자.
> 그 노력은 유효성 검사가 실제 오류를 처음 걸러낼 때 충분히 보상받을 것이다.