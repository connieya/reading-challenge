# 53일차 2024-06-13 p. 326 ~ 331 

## 아이템 55. 옵셔널 반환은 신중히 하라

자바 8전에는 메서드가 특정 조건에서 값을 반환할 수 없을 때 취할 수 있는 선택지가 두 가지 있었다. 
예외를 던지거나, (반환 타입이 객체 참조라면) null 을 반환하는 것이다.
두 방법 모두 허점이 있다.  예외는 진짜 예외적인 상황에서만 사용해야 하며 
예외를 생성할 때 스택 추적 전체를 캡처하므로 비용도 만만치 않다. null 을 반환하며 이런 문제가 생기지 않지만, 
그 나름의 문제가 있다. null 을 반환하면 이런 문제가 생기지 않지만, 그 나름의 문제가 있다. 
null 을 반환할 수 았는 메서드를 호출할 때는 (null 이 반환될 일이 절대 없다고 확신하지 않는 한 ) 별도의 null 처리 코드를 추가해야 한다.
null 처리를 무시하고 반환된 null 값을 어딘가에 저장해두면 언젠가 NullPointerException 이 발생할 수 있다. 
그것도 근본적인 원인 , 즉 null 을 반환하게 한 실제 원인과는 전혀 상관없는 코드에서 말이다.

자바 버전이 8로 올라가면서 또 하나의 선택지가 생겼다. 그 주인공인 Optional<T> 는 null 이 아닌 T 타입 참조를 하나 담거나, 
혹은 아무것도 담지 않을 수 있다. 아무것도 담지 않은 옵셔널은 '비었다'고 말한다. 반대로 어떤 값을 담은 옵셔널은 '비지 않았다'고 한다.
옵셔널은 원소를 최대 1개 가질 수 있는 '불변' 컬렉션이다. 
Optional<T> 가 Collection<T> 를 구현하지는 않았지만, 원칙적으로 그렇다는 말이다.


옵셔널을 반환하는 메서드는 예외를 던지는 메서드보다 유연하고 사용하기 쉬우며, null 을 반환하는 메서드보다 
오류 가능성이 작다.

아이템 30 에서도 등장했던 코드 55-1 은 주어진 컬렉션에서 최댓값을 뽑아주는 메서드다.

`코드 55-1 컬렉션에서 최댓값을 구한다. ( 컬렉션이 비었으면 예외를 던진다. )`

````java
 public static <E extends Comparable<E>> E max(Collection<E> c ) {
        if (c.isEmpty()) {
            throw new IllegalArgumentException("빈 컬렉션");
        }
        E result = null;
        for (E e : c) {
            if (result == null || e.compareTo(result) < 0) {
                result = Objects.requireNonNull(e);
            }
        }
        return result;
    }
````

이 메서드에 빈 컬렉션을 건네면 IllgalArgumentException 을 던진다. 
아이템 30 에서도 Optional<E> 를 반환하는 편이 더 낫다고 이야기 했는데, 
그렇게 수정한 모습은 다음과 같다.

```java
public static <E extends Comparable<E>> Optional<E> max(Collection<E> c ) {
        if (c.isEmpty()) {
            return Optional.empty();
        }
        E result = null;
        for (E e : c) {
            if (result == null || e.compareTo(result) < 0) {
                result = Objects.requireNonNull(e);
            }
        }
        return Optional.of(result);
    }
```

보다시피 옵셔널을 반환하도록 구현하기는 어렵지 않다. 
적절한 정적 팩터리를 사용해 옵셔널을 생성해주기만 하면 된다. 
이 코드에서는 두 가지 팩토리를 사용했다. 빈 옵셔널은 Optional.empty() 로 만들고, 
값이 든 옵셔널은 Optional.of(value) 로 생성했다. Optional.of(value) 에 null 을 넣으면
NullPointerException 을 던지니 주의하자. null 값도 허용하는 옵셔널을 만들라면 Optional.ofNullable(value) 을 사용하면 된다.

**옵셔널을 반환하는 메서드에서는 절대 null 을 반환하지 말자.** 
옵셔널을 도입한 행위를 완전히 무시하는 행위다. 

스트림의 종단 연산 중 상당수가 옵셔널을 반환한다. 앞의 max 메서드를 스트림으로 다시 작성한다면
Stream 의 max 연산이 우리에게 필요한 옵셔널을 생성해줄 것이다. (비교자를 명시적으로 전달해야 하지만)

`코드 55-3 컬렉션에서 최댓값을 구해 Optional<E> 로 반환한다. - 스트림 버전`

```java
public static <E extends Comparable<E>> Optional<E> max(Collection<E> c ) {
        return c.stream().max(Comparator.naturalOrder());
    }

```

그렇다면 null 을 반환하거나 예외를 던지는 대신 옵셔널 반환을 선택해야 하는 기준은 무엇인가?
**옵셔널은 검사 예외와 취지가 비슷하다.** 즉, 반환값이 없을 수도 있음을 API 사용자에게 명확히 알려준다.
비검사 예외를 던지거나 null 을 반환한다면 API 사용자가 그 사실을 인지하지 못해 끔직한 결과로 이어 질 수 있다.
하지만 검사 예외를 던지면 클라이언트에서는 반드시 이에 대처하는 코드를 작성해넣어야 한다.

비슷하게, 메서드가 옵셔널을 반환한다면 클라이언트는 값을 받지 못했을 때 취할 행동을 선택해야 한다. 
그중 하나는 기본값을 설정하는 방법이다.

`코드 55-4 옵셔널 활용 1 - 기본값을 정해둘 수 있다.`

또는 상황에 맞는 예외를 던질 수 있다. 다음 코드에서 실제 예외가 아니라 예외 팩토리를 건넨 것에 주목하자. 
이렇게 하면 예외가 실제로 방생하지 않는 한 예외 생성 비용은 들지 않는다.

`코드 55-5 옵셔널 활용 2 - 원하는 예외를 던질 수 있다.`

옵셔널에 항상 값이 채워져 있다고 확신한다면 그냥 곧바로 값을 꺼내 사용하는 선택지도 있다. 
다만 잘못 판단한 것이라면 NoSuchElementException 이 발생할 것이다.

`코드 55-6 옵셔널 활용 3 - 항상 값이 채워져 있다고 가정한다.`

자바 9에서는 Optional 에 stream() 메서드가 추가되었다. 이 메서드는 Optional 을 Stream 으로 변환해주는 
어댑터다. 옵셔널에 값이 있으면 그 값을 원소로 담은 스트림으로, 값이 없다면 빈 스트림으로 변환한다, 
이를 Stream 의 flatMap 메서드와 조합하면 앞의 코드를 다음처럼 명료하게 바꿀 수 있다.

```java
streamOfOptinals
        .flatMap(Optinal::stream)
```

반환값으로 옵셔널을 사용한다고 해서 무조건 득이 되는 건 아니다. 
**컬렉션 ,스트림, 배열 , 옵셔널 같은 컨테이너 타입은 옵셔널로 감싸면 안 된다.**

빈 Optional<List<T>> 를 반환하기보다는 빈 List<T> 를 반환하는 게 좋다.

빈 컨테이너를 그대로 반환하면 클라이언트에 옵셔널 처리 코드를 넣지 않아도 된다. 
그렇다면 어떤 경우에 메서드 반환 타입을 T 대신 Optional<T> 로 선언헤야 할까?
기본 규칙은 이렇다. **결과가 없을 수 있으며, 클라이언트가 이 상황을 특별하게 처리해야 한다면 Optional<T> 를 반환한다.**

박싱된 기본 타입을 담는 옵셔널은 기본 타입 자체보다 무거울 수 밖에 없다. 값을 두 겹이나 감싸기 때문이다. 
그래서 자바 API 설계자는 int , long , double 전용 옵셔널 클래스들을 준비해놨다. 
바로 OptionalInt, OptionalLong , OptionalDouble 이다. 

이 옵셔널들도 Optional<T> 가 제공하는 메서드를 거의 다 제공한다. 
이렇게 대체재까지 있으니 **박싱된 기본 타입을 담은 옵셔널을 반환하는 일은 없도록 하자.**

단, '덜 중요한 기본 타입'용인 Boolean, Byte , Character , Short , Float 은 예외일 수 있다.

지금까지 옵셔널을 반환하고 반환된 옵셔널을 처리하는 이야기를 나눴다. 
다른 쓰임에 관해서는 논하지 않았는데, 대부분 적절치 않기 때문이다. 
예컨대 옵셔널을 맵의 값으로 사용하면 절대 안된다. 만약 그리 한다면 맵 안에 키가 없다는 사실을 나타내는 방법이 두 가지가 된다.

하나는 키 자체가 없는 경우고 , 다른 하나는 키는 있지만 그 키가 속이 빈 옵셔널인 경우다. 
쓸데없이 복잡성만 높여서 혼란과 오류 가능성을 키울 뿐이다. 더 일반화해 이야기하면
**옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는 게 적절한 상황은 거의 없다.**


> **핵심 정리**
> <br/>
> 값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야하는 메서드라면
> 옵셔널을 반환해야 할 상황일 수 있다. 하지만 옵셔널 반환에는 성능 저하가 뒤따르니, 
> 성능에 민감한 메서드라면 null 을 반환하거나 예외를 던지는 편이 나을 수 있다.
> 그리고 옵셔널을 반환값 이외의 용도로 쓰는 경우는 매우 드물다.


