# 5일차 p.69 ~ 79

## 스케줄링 : 개요

### 워크로드에 대한 가정

프로세스가 동작하는 일련의 행위를 워크로드(workload)라 한다.


### 스케줄링의 평가 항목

반환 시간(turnaround time) 은 작업이 완료된 시각에서 작업이 도착한 시각을 뺀 시간이다.

### 선입선출

선입선출 (First In First Out , FIFO)  또는 선도착선처리 (First Come First Served , FCFS) 스케줄링

FIFO는 장점이 많다. 단순하다. 구현하기 쉽다.


`FIFO가 그렇게 좋은 스케줄링이 아닌 이유`

FIFO 의 문제점은 시스템의 평균 반환 시간이 늘어 날 수 있다는 것이다.

이 현상을 convoy effect 라고 부른다.  CPU를 많이 필요로 하지 않는 프로세스들이, CPU 를 오랫동안 사용하는 프로세스가 끝나기를 기다리는 현상


### 최단 작업 우선

convoy effect 문제는 간단히 해결할 수 있다.

최단 작업 우선 (Shortest Job First , SJF)

모든 작업이 동시에 도착한다면 SJF 가 최적의 스케줄링 알고리즘임을 증명할 수 있다.

### 최소 잔여 시간 우선

가정 3(작업은 끝날 때까지 계속 실행된다)을 완화해야 한다.

즉, 작업은 실행 도중에 중단될 수 있다.

앞서 다룬 SJF 는 비선점형 스케줄러이기 때문에, 실행중인 작업을 중지하고 다른 작업을 실행하지 못한다.

SJF 에 선점 기능을 추가한 스케줄러를 최단 잔여시간 우선(Shortest Time-to-Competion , STCF) 또는 선점형 최단 작업 우선이라 한다.

새로운 작업이 도착하면, 이 스케줄러는 현재 실행중인 작업의 잔여 실행 시간과 새로운 작업의 잔여 실행 시간을 비교하여, 
잔여 실행 시간이 가장 작은 작업을 스케줄한다. 

새로운 가정 하에서 STCF가 최적의 스케줄러이다. 작업들이 동시에 도착할 경우, SFJ 가 최적의 결과를 낸다는 것은 고려하면, 
STCF 가 최적의 스케줄링이 되는 이유를 쉽게 알 수 있을 것이다.

### 새로운 평가  시간: 응답 시간

작업의 길이를 미리 알고 있고, 작업이 오직 CPU 만  사용하며, 평가 기준이 반환 시간 하나라면, STCF 는 매우 훌륭한 정책이다.

초기 일괄처리 컴퓨터 시스템에서는 이러한 스케줄링 알고리즘의 의미가 있었다. 그러나 시분할 컴퓨터의 등장이 모든 것을 
바꾸었다. 이제 사용자는 터미널에서 작업하게 되어 시스템에게 상호작용을 원활히 하기 위한 성능을 요구하게 되었다.

응답 시간(response time) 은 작업이 도착하는 시점부터 처음으로 스케줄 될 때까지의 시간으로 정의 된다.


단지 다른 작업이 당신의 작업보다 먼저 스케줄 되었다는 이유로 시스템의 응답이 올 때까지 10초 기다리는 것을 상상해 보자.

별로 즐거운 일은 아니다.

우리는 이제 다른 종류의 문제를 해결해야 한다. 응답 시간을 최소화하는 스케줄러는 어떻게 만들까?

### 라운드 로빈

RR은 작업이 끝날 때까지 기다리지 않는다.

대신 일정 시간 동안 실행한 후 실행 큐의 다음 작업으로 전환한다.

이때 작업이 실행 되는 일정 시간을 타임 슬라이스(time slice) 또는 스케줄링 퀀텀(scheduling qauntum)이라 부른다.

타임 슬라이스의 길이는 RR 에게 매우 중요하다. 타임 슬라이스가 짧을 수록, 응답 시간 기준으로 RR의 성능은 더 좋아진다.

그러나 타임 슬라이스를 너무 짧게 지정하면 문제가 생긴다. 짧게 지정하면 문맥 교환 비용이 전체 성능에 큰 영향을 미치게 된다.

문맥 교환 비용에는 레지스터를 저장/복원하는 작업만 있는 것이 아니다. CPU 캐시, TLB , 분기 예측 등을 비롯하여 
다른 하드웨어에도 프로그램과 관련된 다양한 작업 정보들이 저장되어 있다.

작업이 전환되면 이 정보들을 모두 갱신되어야 한다. 갱신작업이 매우 큰 성능 비용을 유발한다.

적당한 길이의 응답 시간이 유일한 평가 기준인 경우 타임 슬라이스를 가진 RR은 매우 훌륭한 스케줄러이다.

반환 시간이 유일한 측정 기준인 경우 RR이 확실히 최악의 정책이라는 것을 놀라운 일이 아니다.

일반적으로 RR과 같은 공정한 정책, 즉 작은 시간 단위로 모든 프로세스에게 CPU를 분배하는 정책은 반환 시간과 같은 평가 기준에서는 성능이 나쁘다.


SJF 는 반환 시간 측면에서 좋은 성질을 보이지만, 응답 시간은 좋지 않다.
RR 은 응답 시간 측면에서는 좋지만,반환시간 측면에서는 좋지 못한
특성을 갖고 있다.


### 입출력 연산의 고려

입출력 요청을 발생시킨 작업은 입출력 완료를 기다리며 대기 상태가 된다.

입출력이 완료되면 인터럽트가 발생하고 운영체제가 실행되어 입출력을 요청한 프로세스를 대기 상태에서 준비 상태로 다시 이동시킨다.

### 만병 통치약은 없다. (No More Oracle)

### 요약