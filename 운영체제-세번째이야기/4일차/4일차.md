# 4일차 p.53 ~ 67

## 제한적 직접 실행 원리 (Limited Direct Execution)

### 비협조 방식 : 운영체제가 제어권 확보

시스템 콜의 호출이 없더라도, 운영체제에게 제어권을 넘길 수 있는 방법은

바로 타이머 인터럽트(timer interrupt)를 이용하는 것이다.


운영체제는 타이머 인터럽트가 발생 시 실행해야 할 코드의 주소를 기록해두어야 한다.

컴퓨터 부팅시, 운영체제는 컴퓨터에서 정의된 각 인터럽트에 대해, 관련 인터럽트 핸들러의 위치를
테이블 형태로 메모리에 초기화 시킨다.

부팅 시, 운영체제는 타이머를 시작한다.

타이머가 시작되면, 타이머 인터럽트가 주기적으로 발생시킨다.  예를 들어 10 msec 이다.


### 문맥의 저장과 복원

프로세스를 계속 실행할 것인지 아니면 다른 프로세스로 전환할 것인지를 결정해야 한다.
이 결정은 운영체제의 스케줄러(scheduler) 라는 부분에 의해 내려진다.

현재 프로세스를 중단하고 다른 프로세스를 실행하기로 결정을 하면 운영체제는 문맥 교환(context switch) 이라 불리는 코드를 실행한다.

운영체제가 마지막으로 return-from-trap 명령어를 실행하면,  새로이 실행될 프로세스의 커널 스택에서 레지스터 값들을 복원하여
새로운 프로세스의 실행이 시작된다.


프로세스 A의 실행이 타이머 인터럽트에 의해 중단된다. 하드웨어는 A의 레지스터를 커널 스택에 저장하고 커널 모드로 진입한다.

타이머 인터럽트 핸들러에서 운영체제는 프로세스 B로 전환하기로 결정한다.

운영체제는 switch() 루틴을 호출한다. 이 루틴이 A가 사용하는  레지스터 값들을 A의 프로세스 구조체에 저장하고
B의 프로세스 구조체에 저장되어있던 레지스터 값들을 복원한다. 

### 병행실행으로 인한 문제

"만약 시스템 콜을 처리하는 도중에 타이머 인터럽트가 발생하면 어떻게 해야할까?"

또는 "하나의 인터럽트를 처리하고 있을 때 다른 인터럽트가 발생하면?"

커널에서 처리하기 더 어려워지는 것은 아닌가?

간단한 해법은 인터럽트를 처리하는 동안에는 인터럽트를 불능화시키는 것이다.


### 요약



제한적 직접  실행

원하는 프로그램을 실행한다. 하드웨어를 적절히 설정하여, 프로세스가 할 수 있는 작업을 제한하고, 
중요한 작업을 실행할 때는 반드시 운영체제를 거치도록 한다. 